/*
 * Copyright 2015-2021 NXP
 * This software is owned or controlled by NXP and may only be used strictly
 * in accordance with the applicable license terms.  By expressly accepting
 * such terms or by downloading, installing, activating and/or otherwise using
 * the software, you are agreeing that you have read, and that you agree to
 * comply with and are bound by, such license terms.  If you do not agree to
 * be bound by the applicable license terms, then you may not retain, install,
 * activate or otherwise use the software.
 */

#ifndef __MSG_H_
#define __MSG_H_

#include <stdint.h>
#include <stdbool.h>
#include "chip.h"
#include "msg_dft.h"
#include "msg_cmd.h"
#include "msg_response.h"

/**
 * @defgroup MODS_NSS_MSG msg: Message Handler
 * @ingroup MODS_NSS
 * The message handler is a module which provides a command - response message mechanism to help an upper layer to
 * communicate with an external device. It is purely a software implementation without any direct dependency on hardware
 * or transport layer. Using the message handler module, the upper layer can easily add or remove commands and
 * responses, both at compile time and at runtime - by tweaking the diversity settings the module offers.
 * At all times, the upper layer retains full control on what is received, what is parsed, what is generated and what is
 * sent.
 *
 * @par Definitions
 *  A few definitions make the explanations below more clear:
 *  <dl><dt>Command</dt><dd>A sequence of bytes following a @ref msg_anchor_protocol "Protocol" that is given to the
 *      message handler module that forms an instruction to perform an action. @n
 *      When looking at system level, commands are typically sent by the tag reader via the NFC interface. On a few
 *      occasions, the application may generate commands itself, based on some events or interrupts, and then feed
 *      that to the message handler module.</dd>
 *  <dt>Response</dt><dd>A sequence of bytes following a @ref msg_anchor_protocol "Protocol" that is generated to
 *      partially or fully complete the action(s) requested by a previously received command and that is to be sent out
 *      via any transport layer. @n
 *      When looking at system level, responses are always generated by some handler function, called by the message
 *      handler module. When generated, the message handler module
 *      will present it to the application, who then typically wraps them in an NDEF message and copied it to the NFC
 *      shared memory. On a few occasions, the application may decide to not forward the response, or to hold off
 *      forwarding the response to a later time.</dd>
 *  <dt>Message</dt><dd>A command or a response. A more generic term when the directionality of the communication path
 *      is not important.</dd>
 *  <dt>Command generator</dt><dd>A part of the upper layer that somehow gets hold of a command. That command may be
 *      originating from a phone, who has copied data to the NFC shared memory, which is then in turn copied by the
 *      firmware application to eventually feed it to the message handler module. The module does not know nor care: the
 *      part of the application that feeds the commands to the message handler module is designated as the 'command
 *      generator'.</dd>
 *  <dt>Command handler</dt><dd>A function, either part of the message handler module or the upper layer, that
 *      interprets the content enclosed in a specific command, takes the appropriate actions and generates the
 *      corresponding responses. The output of the command handler, the response, is given back to the message handler
 *      module who is responsible for further distribution. @n
 *      The message handler module has built-in support for handling commands that are deemed not specific for an
 *      application. For example #MSG_ID_GETVERSION. Others can be enabled or disabled at compile time</dd>
 *  <dt>Response handler</dt><dd>A part of the upper layer that receives responses via a designated callback, and that
 *      is responsible for sending out the generated responses to the originator of the corresponding command.
 *      The response handler is called by the message handler module.</dd>
 *  <dt>Immediate response</dt><dd>The message handler module will ensure that for every command it receives, at least
 *      one response is generated and returned to the upper layer @ref msg_anchor_one_response "(*)". This
 *      first guaranteed response will become available in a synchronous way, i.e. before the call has ended, and will
 *      be made available to the upper layer in the same CPU context as where the command has been given. This means
 *      that in case a specific command handler does not create a response - one may not be available or the designated
 *      message handler may reject generating any response - the message handler module will create one
 *      on that specific command handler's behalf. This first guaranteed response is called the immediate response.
 *      Additional responses may or may not be generated immediately or later - this is command and application
 *      specific.</dd>
 *  <dt>Response generator</dt><dd>Either the message module itself, or the designated command handler. The block that
 *      will generate the immediate response.</dd>
 *  @anchor msg_anchor_direction
 *  <dt>Directionality</dt><dd> Each message requires the presence of a directionality field as part of the
 *      @ref msg_anchor_protocol "Protocol".</dd></dl>
 *
 * @par Overview
 *  The message handler module does not run in its own thread and will not react to interrupts: it has to be explicitly
 *  triggered to do something.
 *
 *  When the upper layer delivers a sequence of bytes to the message handler module, i.e. the upper layer acts as a
 *  <em>Command generator</em>, the message handler module tries to interpret this as a command. Each sequence of bytes
 *  is supposed to constitute one command.
 *
 *  The message handler module maintains a list of known commands and tries to match the incoming command with this
 *  list. If a match is found, i.e. there is a <em>Command handler</em> for this specific command, the corresponding
 *  handler is called. At that point either the handler generates at least one response, i.e. it is also the response
 *  generator, after which the message handler module considers the command handling complete; or no response is
 *  generated, after which the message handler module will generate an immediate response itself, i.e. the message
 *  handler module will take over the role of <em>Response generator</em>.
 *
 * @anchor msg_anchor_protocol
 * @par Protocol
 *  The message handler module uses the following communication protocol for commands and responses. The first byte
 *  shall indicate the message id. The second byte shall indicate the direction of transfer as mentioned below:
 *      - value of 0x0 for commands coming into message mod
 *      - value of 0x1 for responses going out from message mod
 *  This is followed by the optional payload specific for each command/response. Details of the commands and
 *  responses are captured in the following sections.
 *  @note The NTAG SmartSensor family uses the NFC as a bi-directional communication path. But using the NFC technology
 *      it is not possible to flag the presence of new data to the tag reader: it is up to the tag reader to decide when
 *      to read. Waiting too long slows down communication, waiting a too short time results in reading out the previous
 *      data, likely the command bytes that the tag reader itself wrote in the NFC memory. Since it is possible that the
 *      exact same bytes constitute the response from the tag, the directionality byte is added as a means to
 *      distinguish commands from responses unambiguously. This byte is added as an aid for the tag reader: the tag
 *      itself has sufficient interrupt option at his disposal to know when a new message was written by the tag.
 *
 * @par Commands
 *  A command can be any sequence of bytes, that adheres to the @ref msg_anchor_protocol "Protocol".
 *
 * @par Handlers
 *  The message handler module has a default list of commands and corresponding command handlers - which can be enabled
 *  and disabled at compile time. The upper layer can at compile time
 *  add handlers for specific commands, or it can make use of a catch-all command handler to dynamically change the way
 *  it handles commands at runtime.@n
 *  Apart from some minimal rules, no predefined formats exist, leaving the application with full freedom how to
 *  implement and handle its own specific commands.
 *
 * @ifnot MSG_PROTOCOL_DOC
 *  A handler can be any function whose prototype match #pMsg_CmdHandler_t.
 *  See #MSG_APP_HANDLERS and #MSG_CATCHALL_HANDLER for more information.
 * @endif
 *
 * @par Responses
 *  Responses are typically generated in a command handler. Generated responses are given to the message handler module,
 *  which then attempts to have them sent by calling a designated callback. That callback can either immediately send
 *  the response over the transport layer of its choosing back to the originator of the command; or reject the response.
 *  When rejected, the message handler module will store the response in its internal buffer; a special command is
 *  available to retrieve them at a later time.
 *
 * @note The device(s), layer(s) or block(s) that creates commands and handles responses can be considered to be the
 *  counter-part of the message handler module. The limitations imposed by the message handler module and the precise
 *  format of each command and response must be known by respected by that counter-part. Changes made to this on one
 *  side must be made as well on the other side.
 *
 * @anchor msg_anchor_one_response
 * @note All commands generate one immediate response. This includes a response for the #MSG_ID_RESET command, but a
 *  subsequent reset will re-initialize all peripherals, including the NFC controller and it NFC shared memory.
 *  All commands may subsequently generate zero, one or multiple additional responses at a later time.
 *
 * @note Some commands are asynchronous in nature: in that case a response still must be immediately returned, denoting
 *  only the acceptance of the command, and subsequent responses provide the requested result.
 *
 * @n
 * @n
 *
 * @par Sequence diagrams
 *  The following example sequence diagrams provide a quick insight in the different interactions.
 *
 *  @if MSG_PROTOCOL_DOC
 *  <dl><dt>Command - response</dt><dd>
 *      The full communication flow between the tag reader and the tag largely follows a strict command - response
 *      sequence. Although the protocol can be used to communicate over any HW block, it is assumed that the NFC
 *      memory is used as transport layer.
 *      @n
 *      - Each time the NHS31xx IC starts, an initial NDEF message must be generated. This is necessary to correctly
 *          identify the IC as an NDEF tag (not just an NDEF-formatable tag) and to provide the application running on
 *          the tag reader with enough information to get started: think of firmware type indication through the MIME
 *          string, version information to unlock all possible functionality, and status information to display a report
 *          to the end-user as fast as possible.
 *          @note The generation of the initial NDEF message is a responsibility of the application: it must internally
 *              generate a command and feed that to the message handler module. The response can then be used to
 *              initialize the NFC shared memory appropriately.
 *
 *          @msc
 *          hscale="1.6", wordwraparcs="true";
 *          A [label="tag reader"],
 *               B [label="NFC controller/\nNFC memory"],
 *                    C [label="tag: firmware\nusing msg module"];
 *          |||;
 *               B >> C    [label="IC start upon\nNFC field detection"];
 *                    C->C [label="Initial message generation"];
 *               B <= C    [label="[1 or more records]\ninitial message"];
 *          A <= B         [label="initial message\nmulti-record mixing TEXT and MIME"];
 *          @endmsc
 *
 *          @note It is the responsibility of the application to generate the initial message as soon as possible, to
 *              ensure that the desired information is present in the NFC memory at the moment that the tag reader
 *              starts reading out the NFC contents.
 *
 *          @n
 *          @n
 *
 *      - From then on, the application firmware waits for an incoming command: an NDEF message, written by the tag
 *          reader, overwriting the initial message. For each command that is written, one response will be created and
 *          stored in the same NFC shared memory, for the tag reader to read out.@n
 *          Also if a command is unknown, badly formatted, or not allowed (for instance, due to access restrictions),
 *          one response will be made available by the tag reader.
 *
 *          @msc
 *          hscale="1.6", wordwraparcs="true";
 *          A [label="tag reader"],
 *               B [label="NFC controller/\nNFC memory"],
 *                    C [label="tag: firmware\nusing msg module"];
 *          |||;
 *          A => B         [label="[msgId, 00h, A, B, C, ... Z]\ncommand: sequence of bytes"];
 *               B >> C    [label="notification upon\nwrite completion"];
 *               B => C    [label="[msgId, 00h, datafield I, datafield II, ...]\ncommand"];
 *                    C->C [label="Generate response"];
 *               B <= C    [label="[msgId, 01h, datafield i, datafield ii, ...]\nresponse"];
 *          A <= B         [label="[msgId, 01h, a, b, c, ... z]\nresponse: sequence of bytes"];
 *          @endmsc
 *
 *          @note It is not possible to notify the tag reader when a response is available in NFC memory. The tag reader
 *              must poll by continually reading the NFC memory until a memory change is detected.
 *
 *          @n
 *          @n
 *
 *      - Some commands take a long time to complete. Even then, one response will be made available immediately.
 *          This immediate response then only acknowledges the acceptance of the command. The requested response can
 *          then later be fetched using the command #MSG_ID_GETRESPONSE. Also when commands trigger multiple responses,
 *          the subsequent responses can be fetched be repetitively issuing the command #MSG_ID_GETRESPONSE.
 *
 *          @msc
 *          hscale="1.6", wordwraparcs="true";
 *          A [label="tag reader"],
 *               B [label="NFC controller/\nNFC memory"],
 *                    C [label="tag: firmware\nusing msg module"];
 *          |||;
 *          A => B         [label="[msgId, 00h, A, B, C, ... Z]\ncommand: sequence of bytes"];
 *               B >> C    [label="notification upon\nwrite completion"];
 *               B => C    [label="[msgId, 00h, datafield I, datafield II, ...]\ncommand"];
 *                    C->C [label="Generate immediate response"];
 *               B <= C    [label="[msgId, 01h, errorcode]\nimmediate response"];
 *          A <= B         [label="[msgId, 01h, a, b, c, d]\nresponse: sequence of bytes"];
 *
 *          ...;
 *          ... [label="...as time passes by..."];
 *          ...;
 *
 *                    C->C [label="Generate final response"];
 *                    C->C [label="Cache final response"];
 *
 *          ...;
 *          ... [label="...as time passes by..."];
 *          ...;
 *
 *          A => B         [label="[MSG_ID_GETRESPONSE, 00h]\ncommand"];
 *               B >> C    [label="notification upon\nwrite completion"];
 *               B => C    [label="[MSG_ID_GETRESPONSE, 00h]\ncommand"];
 *                    C->C [label="pop response"];
 *               B <= C    [label="[msgId, 01h, datafield i, datafield ii, ...]\nresponse"];
 *          A <= B         [label="[msgId, 01h, a, b, c, ... z]\nresponse: sequence of bytes"];
 *          @endmsc
 *
 *          @note It requires precise knowledge of the exact command being sent, to know whether a delayed response or
 *              multiple responses will be made available, and to estimate when these responses are ready to be sent
 *              out.
 *
 *          @n
 *          @n
 *
 *  </dd><dt>Automatic responses</dt><dd>
 *      Not all tag readers are capable of writing to a tag but can only read from one. For example, an iPhone 7 running
 *      iOS 11 will not be able to write configuration data to the tag and start a demonstration session around the
 *      temperature logging use case. A true command - response sequence is in this case not possible. @n
 *      However, the full communication layer present in the SDK can still be used. The communication module is fully
 *      agnostic of the physical transport layer, the firmware application can thus feed it with self-generated commands
 *      each time the NFC HW block reports that the tag reader has read out the NFC memory.
 *      The firmware application can then follow a script, where a sequence of commands is listed that is to be
 *      followed in case the tag reader is incapable of writing and controlling the data flow itself.
 *
 *      This approach is implemented in the <em>NHS3100 temperature logger demo</em>: the firmware application can
 *      switch between an 'automatic' mode, where it generates the commands himself, and the normal 'response' mode,
 *      where it waits for commands written by the tag reader, only reacting on them.
 *      - The Android APP - available in the Google Play Store - will take control, and will write commands to fetch
 *          the data it wants to know.
 *      - The iOS APP - available in the Apple APP store - will repetitively read the NFC memory until no more new data
 *          is being fed by the application firmware. Although the functionality to configure and start a temperature
 *          monitoring session is lacking, it can still do a full data readout of tens of thousands of measurements
 *          points, together with the current status and the conclusion as calculated on the NTAG SmartSensor
 *
 *      A sequence diagram of such an application, where the application firmware implements an 'automatic' mode, can
 *      look as follows:
 *
 *          @msc
 *          hscale="1.6", wordwraparcs="true";
 *          A [label="NFC controller/\nNFC memory"],
 *               B [label="NFC memory"],
 *                    C [label="tag: firmware\nusing msg module"];
 *          |||;
 *               B >> C    [label="IC start upon\nNFC field detection"];
 *                    C->C [label="Initial message generation"];
 *               B <= C    [label="[1 or more records]\ninitial message"];
 *          A <= B         [label="initial message\nmulti-record mixing TEXT and MIME"];
 *               B >> C    [label="Notification upon read completion"];
 *                    C->C [label="Automatic command generation\n[msgId, 00h, datafield I, datafield II, ...]"];
 *                    C->C [label="Generate response"];
 *               B <= C    [label="[msgId, 01h, datafield i, datafield ii, ...]\nresponse"];
 *          A <= B         [label="[msgId, 01h, a, b, c, ... z]\nresponse: sequence of bytes"];
 *               B >> C    [label="Notification upon read completion"];
 *
 *          ...;
 *          ...;
 *          ... [label="...as time passes by..."];
 *          ...;
 *          ...;
 *
 *          A <= B         [label="[msgId, 01h, i, j, k, ... t]\nresponse: sequence of bytes"];
 *               B >> C    [label="Notification upon read completion"];
 *                    C->C [label="End reached of script for\nautomatic command generation"];
 *          ...;
 *          A <= B         [label="[msgId, 01h, i, j, k, ... t]\nresponse: sequence of bytes"];
 *
 *          ...;
 *          ... [label="Closing NFC field after\nduplicate consecutive response detection"];
 *          ...;
 *          ...;
 *          @endmsc
 *
 *          @note Synchronization of the read and write actions in the communication flow is not guaranteed anymore:
 *              - if the tag reader reads too fast during a time consuming response generation, the tag reader may
 *                  erroneously decide the script execution has finished.
 *              - Vice versa, when reading has finished, but a reading error has occurred causing a few bytes to have
 *                  reversed bits, the application firmware cannot be informed to pause its script execution, needed
 *                  to give the necessary time to the tag reader to read the response a second time.
 *              This means that some redundancy and leniency must be implemented on both sides to still ensure a full
 *              correct readout of all the data provided by the implemented use case.
 *
 *          @n
 *          @n
 *
 *  </dd></dl>
 *  @endif
 *
 *  @ifnot MSG_PROTOCOL_DOC
 *  <dl><dt>Basic example</dt><dd>
 *      A very basic example, where each call returns success:
 *
 *      @msc
 *      hscale="1.6", wordwraparcs="true";
 *      C [label="response handler"],
 *           A [label="command generator"],
 *                D [label="message handler module"],
 *                     B [label="command handler/\nresponse generator"];
 *      |||;
 *           A => D         [label="[A, B, C, ... Z]\nsequence of bytes", URL="@ref Msg_HandleCommand"];
 *                D => B    [label="[msgId, dir, C, ... Z]\ncommand", URL="@ref pMsg_CmdHandler_t"];
 *                     B->B [label="Generate response"];
 *                D <= B    [label="[msgId, dir, c, ... z]\nresponse", URL="@ref Msg_AddResponse"];
 *      C <=      D         [label="[a, b, c, ... z]\nsequence of bytes", URL="@ref pMsg_ResponseCb_t"];
 *      @endmsc
 *
 *  </dd><dt>Holding back a response</dt><dd>
 *      In case the response handler is at first 'incapable of handling the response', i.e. of sending out the
 *      response immediately, the response can be retrieved at a later more convenient time:
 *
 *      @msc
 *      hscale="1.6", wordwraparcs="true";
 *      C [label="response handler"],
 *           A [label="command generator"],
 *                D [label="message handler module"],
 *                     B [label="command handler/\nresponse generator"];
 *      |||;
 *           A => D         [label="[A, B, C, ... Z]\nsequence of bytes", URL="@ref Msg_HandleCommand"];
 *                D => B    [label="[msgId, dir, C, ... Z]\ncommand", URL="@ref pMsg_CmdHandler_t"];
 *                     B->B [label="Generate response"];
 *                D <= B    [label="[msgId, dir, c, ... z]\nresponse", URL="@ref Msg_AddResponse"];
 *      C <=      D         [label="[a, b, c, ... z]\nsequence of bytes", URL="@ref pMsg_ResponseCb_t"];
 *      C >>      D         [label="returns false"];
 *                D->D      [label="response stored"];
 *      ...;
 *      ...;
 *      ... [label="...as time passes by..."];
 *      ...;
 *      ...;
 *
 *           A => D         [label="[MSG_ID_GETRESPONSE]\ncommand", URL="@ref Msg_HandleCommand"];
 *                D->D      [label="pop response"];
 *      C <=      D         [label="[a, b, c, ... z]\nsequence of bytes", URL="@ref Msg_AddResponse"];
 *      @endmsc
 *
 *  </dd><dt>Multiple responses per command</dt><dd>
 *      Some commands take time to complete, or cause the generation of multiple responses:
 *
 *      @msc
 *      hscale="1.6", wordwraparcs="true";
 *      C [label="response handler"],
 *           A [label="command generator"],
 *                D [label="message handler module"],
 *                     B [label="command handler/\nresponse generator"];
 *      |||;
 *           A => D         [label="[A, B, C, ... Z]\nsequence of bytes", URL="@ref Msg_HandleCommand"];
 *                D => B    [label="[msgId, dir, C, ... Z]\ncommand", URL="@ref pMsg_CmdHandler_t"];
 *                     B->B [label="Generate response"];
 *                D <= B    [label="[msgId, dir, c, ... z]\nimmediate response", URL="@ref Msg_AddResponse"];
 *      C <=      D         [label="[a, b, c, ... z]\nsequence of bytes", URL="@ref pMsg_ResponseCb_t"];
 *
 *      ...;
 *      ...;
 *      ... [label="...as time passes by..."];
 *      ...;
 *      ...;
 *
 *                     B->B [label="Generate response"];
 *                D <= B    [label="[msgId, dir, c2, ... z2]\nresponse", URL="@ref Msg_AddResponse"];
 *      C <=      D         [label="[a2, b2, c2, ... z2]\nsequence of bytes", URL="@ref pMsg_ResponseCb_t"];
 *
 *      ...;
 *      ...;
 *      ... [label="...as time passes by..."];
 *      ...;
 *      ...;
 *
 *                     B->B [label="Generate response"];
 *                D <= B    [label="[msgId, dir, c3, ... z3]\nresponse", URL="@ref Msg_AddResponse"];
 *      C <=      D         [label="[a3, b3, c3, ... z3]\nsequence of bytes", URL="@ref pMsg_ResponseCb_t"];
 *      @endmsc
 *
 *  </dd><dt>Including the transport layer</dt><dd>
 *      In practice, the role of command generator and response handler may both be taken up by 'the application'.
 *      The sequence diagram below now also an SPI block, to make clear it does not come into direct contact with the
 *      message handler module.
 *
 *      @msc
 *      hscale="1.6", wordwraparcs="true";
 *      E [label="SPI driver"],
 *           AC [label="application"],
 *                 D [label="message handler module"],
 *                      B [label="command handler"];
 *      |||;
 *      E => AC              [label="[A, B, C, ... Z]\nsequence of bytes"];
 *           AC => D         [label="[A, B, C, ... Z]\nsequence of bytes", URL="@ref Msg_HandleCommand"];
 *                 D => B    [label="[msgId, dir, C, ... Z]\ncommand", URL="@ref pMsg_CmdHandler_t"];
 *                      B->B [label="Generate response"];
 *                 D <= B    [label="[msgId, dir, c, ... z]\nresponse", URL="@ref Msg_AddResponse"];
 *           AC <= D         [label="[a, b, c, ... z]\nsequence of bytes", URL="@ref pMsg_ResponseCb_t"];
 *      E <= AC              [label="[A, B, C, ... Z]\nsequence of bytes"];
 *      @endmsc
 *
 *      @note The message handler module only expects full commands: it is either up to the upper layer or up
 *          to the specific command handler functions to guard against missing or superfluous bytes.
 *
 *      As can be seen, it is the application - @b your code - that sits between the communication channel and the
 *      message handling. This can be as thin as a simple pass-through: then the only benefit is a functionality
 *      isolation at the cost of a small overhead. @n
 *      But the application can do more: it can encapsulate the responses, i.e. adding a CRC over
 *      an unreliable communication channel, or creating an NDEF message to send the response as a MIME type NDEFt2t
 *      record; and likewise it may need to validate the incoming commands by checking the CRC, or extracting every
 *      record from an NDEF multi-record message. This also provides a good debugging point, as the entire
 *      command/response flow can be easily logged or printed out over a debug line.
 *  </dd></dl>
 *  @endif
 *
 * @par Internal messages / custom messages
 *  A number of commands and corresponding responses have been predefined by the message handler module. They
 *  can be found in the enumeration #MSG_ID_T. By default only one of them is compiled in to save code space:
 *  #MSG_ID_GETVERSION.
 *
 *  Each command has a corresponding command structure @c MSG_CMD_xxxx_T that describes the fields which are
 *  packed into the command payload, and one or possibly two response structures @c MSG_RESPONSE_xxxx_T that describe
 *  which fields to expect in return, as part of the response payload.
 *
 *  By default, there exist no custom messages: it is up to the application to define and implement them, and to connect
 *  them at compile time.
 *
 * @ifnot MSG_PROTOCOL_DOC
 *
 *  You can add custom messages them by properly defining both #MSG_APP_HANDLERS_COUNT and
 *  #MSG_APP_HANDLERS", and/or by defining #MSG_RESPONSE_DISCARDED_CB. There is no obligation to create structures for
 *  each custom command and corresponding responses: all is well as long as the custom handlers generate the expected
 *  responses.
 *
 * @par Diversity
 *  This module supports a number of diversity flags. Check the
 *  @ref MODS_NSS_MSG_DFT "Message handler module diversity settings" for a full list and their implications.
 *
 * @par How to use the module
 *  Most likely there will be at least a few application specific commands and responses. A first step would then be to
 *  create a list of message id's and functions that act as the command handlers / response generators for these message
 *  id's and to store them in an array of type #MSG_CMD_HANDLER_T.
 *
 *  Each such function is to use #Msg_AddResponse reply to a received command. It is recommended also create a (packed)
 *  command structure and response structure for each message id, as this aids in explicitly describing the message
 *  specific parameters.
 *
 *  Also check the other diversity flags and enable the required functionality. Possibly you'll have to implement a few
 *  callback functions if you want to make use of all the functionality. Couple your 'extensions' using the diversity
 *  flags.
 *
 *  After initializing the message handler module with #Msg_Init and #Msg_SetResponseCb, you just feed it commands via
 *  #Msg_HandleCommand. The whole chain provided by the message handler module and your implemented and coupled
 *  extensions will deliver the responses to the response callback you set.
 *
 * @par Example
 *  Below a minimalistic code-like example is given. This does not cover the full functionality the message handler
 *  module offers, but aids in clarifying how all the pieces are tied together. In the example, one application specific
 *  message is added, then via the transport layer a command with that new id is received. The newly created command
 *  handler generates a response, which is then sent out again.
 *
 * @par Handle function
 *  @snippet msg_mod_example_1.c msg_mod_handle
 *
 * @par Command Handler
 *  @snippet msg_mod_example_1.c msg_mod_cmd_handler
 *  @note Id 0x77 is considered for this example.
 *
 * @par Response callback 'ResponseCb' function
 *  @snippet msg_mod_example_1.c msg_mod_responseCb
 *
 * @par Msg Mod Init
 *  @snippet msg_mod_example_1.c msg_mod_init
 *
 * @par Data receive function
 *  @snippet msg_mod_example_1.c msg_mod_rxdata
 *
 * @endif
 *
 * @{
 */

/* ------------------------------------------------------------------------- */

/**
 * Supported messages.
 * @note Each message comprises of a command and a response. For each command and response a corresponding struct
 *  exists which explains the parameters, their sizes and their use.
 */
typedef enum MSG_ID {

    /**
     * @c 0x01 @n
     * The message handler module holds a queue of responses. Each time a response is created which cannot be sent back
     * immediately (in response to a command), it is queued. It's the task of the host to use this command to retrieve
     * the queued responses.
     * @note When the host doesn't retrieve the responses fast enough, the buffer gets filled up. When a new response
     *  can not be stored any more, the oldest responses are discarded until sufficient room is available to store the
     *  newest response.
     *  @ifnot MSG_PROTOCOL_DOC
     *  The upper layer can get notified when this happens via the diversity setting #MSG_RESPONSE_DISCARDED_CB.
     *  @endif
     * @param Header : Sequence of bytes as per the @ref msg_anchor_protocol "Protocol".
     * @param Payload : @b No payload.
     * @return The response is returned immediately.
     *  - If a response was queued and available for retrieval: the type of the response is determined by the first byte
     *      and is equal to the message id which triggered the generation of this response.
     *  - If no response was queued: #MSG_RESPONSE_RESULTONLY_T with #MSG_RESPONSE_RESULTONLY_T.result equal to
     *      #MSG_ERR_NO_RESPONSE
     * @note synchronous command
     * @ifnot MSG_PROTOCOL_DOC
     * @note For this command to become available, define both #MSG_RESPONSE_BUFFER and #MSG_RESPONSE_BUFFER_SIZE.
     * @endif
     */
    MSG_ID_GETRESPONSE = 0x01,

    /**
     * @c 0x02 @n
     * This message id allows the host to determine the version of the firmware.
     * @param Header : Sequence of bytes as per the @ref msg_anchor_protocol "Protocol".
     * @param Payload : @b No payload.
     * @return MSG_RESPONSE_GETVERSION_T
     * @note synchronous command
     * @note This command is always available.
     */
    MSG_ID_GETVERSION = 0x02,

    /**
     * @c 0x03 @n
     * Generate a SW reset of the digital part of the system.
     * @param Header : Sequence of bytes as per the @ref msg_anchor_protocol "Protocol".
     * @param Payload : @b No payload.
     * @return MSG_RESPONSE_RESULTONLY_T. This response will be available for 500 milliseconds.
     * @note synchronous command
     * @ifnot MSG_PROTOCOL_DOC
     * @note For this command to become available, define #MSG_ENABLE_RESET
     * @endif
     */
    MSG_ID_RESET = 0x03,

    /**
     * @c 0x04 @n
     * Read and return the value from the selected ARM register address.
     * @param Header : Sequence of bytes as per the @ref msg_anchor_protocol "Protocol".
     * @param Payload : #MSG_CMD_READREGISTER_T
     * @return MSG_RESPONSE_READREGISTER_T
     * @note synchronous command
     * @ifnot MSG_PROTOCOL_DOC
     * @note For this command to become available, define #MSG_ENABLE_READREGISTER
     * @endif
     */
    MSG_ID_READREGISTER = 0x04,

    /**
     * @c 0x05 @n
     * Write the data supplied by the host to the selected ARM register address.
     * @param Header : Sequence of bytes as per the @ref msg_anchor_protocol "Protocol".
     * @param Payload : #MSG_CMD_WRITEREGISTER_T
     * @return MSG_RESPONSE_RESULTONLY_T.
     * @note synchronous command
     * @ifnot MSG_PROTOCOL_DOC
     * @note For this command to become available, define #MSG_ENABLE_WRITEREGISTER
     * @endif
     */
    MSG_ID_WRITEREGISTER = 0x05,

    /**
     * @c 0x06 @n
     * Read and return the value from the selected address.
     * @param Header : Sequence of bytes as per the @ref msg_anchor_protocol "Protocol".
     * @param Payload : #MSG_CMD_READMEMORY_T
     * @return MSG_RESPONSE_READMEMORY_T.
     * @note synchronous command
     * @ifnot MSG_PROTOCOL_DOC
     * @note For this command to become available, define #MSG_ENABLE_READMEMORY
     * @endif
     * @note The address range may be part of SRAM, Flash or EEPROM.
     * @warning It is assumed the address region is accessible and can be read. This is @b not checked for.
     *  e.g. This implies it is the application's responsibility to ensure the EEPROM is initialized
     *  when reading EEPROM data, and that it is the caller's responsibility to ensure the range can be mapped to valid
     *  addresses.
     */
    MSG_ID_READMEMORY = 0x06,

    /**
     * @c 0x07 @n
     * Write the data supplied by the host to the selected ARM memory address.
     * @param Header : Sequence of bytes as per the @ref msg_anchor_protocol "Protocol".
     * @param Payload : #MSG_CMD_WRITEMEMORY_T
     * @return MSG_RESPONSE_RESULTONLY_T.
     * @note synchronous command
     * @ifnot MSG_PROTOCOL_DOC
     * @note For this command to become available, define #MSG_ENABLE_WRITEMEMORY
     * @endif
     * @warning Only SRAM can be written to. It is assumed the address region which is referred to is fully part of
     *  SRAM. This is @b not checked for.
     */
    MSG_ID_WRITEMEMORY = 0x07,

    /**
     * @c 0x08 @n
     * Configures and enables the SWD lines, then waits in an endless while loop. This allows a developer to attach
     * a debugger to the running device.
     * @param Header : Sequence of bytes as per the @ref msg_anchor_protocol "Protocol".
     * @param Payload : @b No payload.
     * @return MSG_RESPONSE_RESULTONLY_T.
     * @note synchronous command
     * @note When a debugging session has been established, set the boolean @c gMsgWaitForDebugConnection to @c false
     *  to return from the command handler.
     * @ifnot MSG_PROTOCOL_DOC
     * @note For this command to become available, define #MSG_ENABLE_PREPAREDEBUG
     * @note Usage of this message id will be difficult in combination with the watch dog timer. Be sure the WDT is not
     *  enabled when you plan to use this debug message.
     * @endif
     */
    MSG_ID_PREPAREDEBUG = 0x08,

    /**
     * @c 0x09 @n
     * Retrieve the unique identifier of the IC. This is the device serial number guaranteed unique among all NHS31xx
     * ICs.
     * @note This is @b not equal to the NFC ID, which is a randomly assigned number.
     * @param Header : Sequence of bytes as per the @ref msg_anchor_protocol "Protocol".
     * @param Payload : @b No payload.
     * @return MSG_RESPONSE_GETUID_T
     * @note synchronous command
     * @ifnot MSG_PROTOCOL_DOC
     * @note Enabled by default. To disable this command, undefine #MSG_ENABLE_GETUID.
     * @endif
     */
    MSG_ID_GETUID = 0x09,

    /**
     * @c 0x0a @n
     * Retrieve the NFC identifier of the IC. This is the serial number assigned to the NFC controller and stored in
     * the first two pages of the NFC shared memory.
     * @note This is a random number assigned during production of the IC. It is @b not guaranteed unique among all
     *  NHS31xx ICs.
     * @note This is @b not equal to the device UID.
     * @param Header : Sequence of bytes as per the @ref msg_anchor_protocol "Protocol".
     * @param Payload : @b No payload.
     * @return MSG_RESPONSE_GETUID_T
     * @note synchronous command
     * @ifnot MSG_PROTOCOL_DOC
     * @note Enabled by default. To disable this command, undefine #MSG_ENABLE_GETNFCUID.
     * @endif
     */
    MSG_ID_GETNFCUID = 0x0a,

    /**
     * @c 0x0b @n
     * Generates whether the BOD is triggered under extra load. Use this to check battery impedance.
     * @param Header : Sequence of bytes as per the @ref msg_anchor_protocol "Protocol".
     * @param Payload : @b No payload.
     * @return #MSG_RESPONSE_RESULTONLY_T immediately; @n
     *  If @c result was equal to #MSG_OK, #MSG_RESPONSE_CHECKBATTERY_T thereafter. This may take several 100 ms.
     *  This second response must be fetched by issuing a command with #MSG_ID_GETRESPONSE
     * @note asynchronous command
     * @note For this command to become available, define @c MSG_ENABLE_CHECKBATTERY
     * @warning This check has a (small) negative impact on the battery. And, this check potentially can cause a reset.
     *  An application may be prudent by blocking this message while a reset is not desired, e.g. during a monitoring
     *  session in a logger application. This can be done by implementing @c MSG_COMMAND_ACCEPT_CB
     */
    MSG_ID_CHECKBATTERY = 0x0b,

    /**
     * @c 0x0b @n
     * Retrieves the timestamps of when the temperature calibration took place (at 30C and 85C).
     * @param Header : Sequence of bytes as per the @ref msg_anchor_protocol "Protocol".
     * @param Payload : @b No payload.
     * @return MSG_RESPONSE_GETCALIBRATIONTIMESTAMP_T
     * @note synchronous command
     * @ifnot MSG_PROTOCOL_DOC
     * @note Enabled by default. To disable this command, undefine #MSG_ENABLE_GETCALIBRATIONTIMESTAMP.
     * @endif
     */
    MSG_ID_GETCALIBRATIONTIMESTAMP = 0x0c,

    /** Obsolete. Do not use. */
    MSG_ID_OBSOLETE_3E = 0x3E,

    /**
     * @c 0x3F @n
     * This message id does not encompass a command or a response. It is used to signify the highest id that is reserved
     * for use by the message handler itself. All application specific commands - which are to be handled by setting a
     * specific handler - must use id's greater than this value.
     * @note Only to be used as an offset for your own application specific commands and responses.
     * @see Cmd_SetApplicationHandler
     */
    MSG_ID_LASTRESERVED = 0x3F

} MSG_ID_T;

/* ------------------------------------------------------------------------- */

/** @cond !MSG_PROTOCOL_DOC */

/**
 * Initializes the module.
 * @pre This must be the first function called of this module.
 * @note May be called multiple times. Whenever called, the response buffer will be cleared.
 */
void Msg_Init(void);

/**
 * Register a callback function that will be called whenever an immediate response is available.
 * @param cb : The function to call that will send the response to the host. May not be @c NULL.
 *  @pre This must be set before calling #Msg_HandleCommand.
 * @note The given function will be called under the same context as the previous call to #Msg_AddResponse, or the
 *  previous call to #Msg_HandleCommand with id #MSG_ID_GETRESPONSE
 */
void Msg_SetResponseCb(pMsg_ResponseCb_t cb);

/**
 * Try to send the response back to the upper layer. If this fails and a buffer has been made available via the
 * diversities #MSG_RESPONSE_BUFFER and #MSG_RESPONSE_BUFFER_SIZE, store the response
 * so it can be given to the upper layer at a later time.
 * @note If a function has been assigned to #MSG_RESPONSE_DISCARDED_CB, and no
 *  response buffer is available, this function will have been called before this function exits in case the upper layer
 *  refuses the response. That callback will also have been called when pushing this response into the response buffer
 *  causes the oldest response(s) to be popped out.
 * @param msgId : Holds the id of the message
 * @param payloadLen : Size in bytes of the response
 * @param pPayload : May not be @c NULL. Points to @c payloadLen number of bytes, which forms the complete response.
 */
void Msg_AddResponse(uint8_t msgId, int payloadLen, const uint8_t* pPayload);

/**
 * To be called each time a command has been received via any communication channel.
 * @param cmdLength : The size in bytes in @c pCmdData
 *  @pre @c cmdLength >= 2
 * @param pCmdData : Pointer to the array containing the raw command bytes as specified
 *  by @ref msg_anchor_protocol "Protocol".
 *  @pre data retention of the bytes contained in @c pCmdData must be guaranteed until the function returns.
 * @post The callback function as registered in the call to #Msg_SetResponseCb will have been called.
 * @post Multiple consecutive calls to that same callback function may be issued after this call has ended.
 */
void Msg_HandleCommand(int cmdLength, const uint8_t* pCmdData);

/** @endcond */

#endif /** @} */
